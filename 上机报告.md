# 上机报告
## 顺序表上机题目
### T1 
1. 题目表述: 取出一个顺序表中重复的数据
2. 算法思想: 利用快慢指针法,首先定义一个快指针指向表头,利用快指针遍历整个数组,定义一个慢指针指向表头,slow指针用以记录不重复元素的索引,之后fast指针遍历数组时,遇到不和slow指向的元素相等的元素就可以把fast指向的元素赋值给slow+1指向的元素,循环结束条件自然时fast< 顺序表长度
3. 时间复杂度: 为O(n),空间复杂度:没有额外消耗空间
### T2
1. 题目表述: 排除数组中的所有的0元素(2 0 0 3 1 0 0 4-> 2 3 1 4)
2. 算法思想: 还是利用快慢指针法,快指针fast的作用就是遍历整个数组,慢指针的作用就是得到新数组中每一个元素的新的索引,类似于leetcode中移动0的问题,但是本题中没有提及到移动0的要求,所以只用把fast指向的值赋值给slow指向的值即可(只要p[ fast]!=0,就可以赋值给p[slow ] )
3. 时间复杂度: O(n),空间复杂度: 没有消耗额外空间
### T3
1. 三种基本排序方式算法的实现(冒泡,选择,插入)
2. 算法实现(都是以升序为例子):
    1. 冒泡排序:就是把数值大的数字移动到最后面,每一次都是一个数组和它后面的一个数字进行比较,如果前面的数字比后面的数字大,就会冒泡到后面去(外层循环有n-1次,内存循环有n-1-i次)
    2. 插入排序: 我的实现思路是首先定义一个函数找到最大的不符合升序排列的索引位置,从这个位置开始之后,不断和前面的数字进行比较,如果比前面的数字小,就可以往前面排列(其实就是交换),依次类推即可
    3. 选择排序: 和冒泡排序相反,所有符合要求的数字都会移动到前面,每一次比较都是和最前的一个数字进行比较(外层循环为i时,就会和索引为i的元素进行比较)
3. 算法性能分析: 三种排序方式的时间复杂度都是O(n^2),空间复杂度都是没有消耗额外的空间
### T4
1. 题目描述: 字符串的模式匹配问题
2. 算法描述: 还是经典的暴力求解,首先定义两个指针指向字符串的头部,之后开始移动指针的位置,如果两个指针指向的内容相同,就可以同时向后面移动指针,如果指向的内容不同,指向主串的指针就会回溯到开始位置的下一个位置开始匹配(i=i-j+1),子串的指针就会回溯到0位置开始匹配(j=0)
3. 算法分析: 时间复杂度: O(n),空间复杂度: 没有额外消耗空间
## 单链表上机题目
### T1
1. 题目描述: 单链表逆置
2. 算法描述:
    1. 思路1: 可以使用双指针法进行分析,pre指向前面一个节点,cur是pre后面一个节点,每一次就可以把cur的后继节点设置为pre,之后不断移动pre和cur,就可以完成链表的逆转,但是不要忘首元节点和尾节点的处理
    2. 思路2: 可以利用递归算法,此时只用关注头节点和首元节点和之后节点的指向关系了
3. 算法分析: 思路1的时间复杂度为O(n),没有额外占据空间,思路2的时间复杂度是o(log n),额外占用了空间(就是函数入栈时占用的空间)
### T2
1. 题目描述: 找到单链表的中点
2. 算法思想: 还是利用经典的快慢指针法,快指针每一次走两步,慢指针每一次走一步,当快指针走到尾部时,慢指针就走到了中点
3. 算法分析: 时间复杂度: O(n),空间复杂度: 没有消耗额外空间
### T3
1. 题目描述:找到单链表倒数第k个节点
2. 算法思想: 利用快慢指针法,首先fast指针先走k+1步,之后slow指针开始迁移,fast指针和slow指针同时走,当fast指针走到结尾时,slow指针就走到了倒数第k个节点的上一个节点,slow->next就是倒数第k个节点(其实时为了方便删除元素)
3. 算法分析: 时间复杂度:O(n),空间复杂度: 没有消耗额外空间
### T4
1. 题目表述: 删除单链表倒数第k个节点
2. 算法思想: 就是利用快慢指针法找到倒数第k个节点的前面一个节点,之后就可以通过经典的删除算法实现元素的删除了
3. 算法分析: 时间复杂度:O(n),空间复杂度:基本没有消耗额外空间
### T5
1. 题目表述: 判断单链表是否有环,如果有环的话就要找出交点
2. 算法思路: 首先定义一个快指针每一次走两个索引,慢指针每一次走一个索引,记录快慢指针的相遇点,之后就可以定义一个指针指向相遇点,一个指针指向head->next,两个指针同时移动,最后相遇的位置就是要求的入环点
3. 算法的原理(手写):
![alt text](IMG_20240310_222711_edit_770234309507139.jpg)
4. 算法分析: 由于n的有限性,时间复杂度为O(n),空间复杂度: 没有消耗额外的空间
### T5
1. 题目表述: 判断链表是否有交点
2. 算法思路: 首先可以求得两个链表的长度,之后定义两个指针指向两个链表的头部,之后就可以把长链表的头指针向后面移动长度差个索引,两个指针处于同一个起点,之后不断比较即可
3. 时间复杂度: O(n),空间复杂度: 没有消耗额外空间
### T6
1. 题目表述: 对于有序链表删除重复节点(保留一个节点/无保留)
2. 算法思路: 还是利用经典的双指针法,fast指针向后面遍历节点,slow记录节点的位置,如果fast->data!=slow->data,就可以把slow+1指向的元素赋值为fast即可,删除之后的元素即可(有损的情况下就可以直接覆盖slow对应的元素,就是如果fast->next->data!=fast->data的话就可以进行覆盖,但是注意fast之后的移动,注意两种方法中slow的作用都是记录链表 中满足要求的元素的位置)(注意删除所有重复元素时,还要兼顾头部和尾部的数据),中间循环体中的数据没有开了头节点和为节点(单链表中定义pre节点的唯一作用就是便于删除节点,确定就是要判断头节点和尾节点)
3. 算法分析: 时间复杂度:O(n),空间复杂度: 没有消耗额外空间
### T8
1. 题目描述: 约瑟夫问题
2. 算法思想: 注意此时构造的单链表一定不要有虚拟头节点(便于构成一个环形链表),就是找到开始节点(就是第k个节点,之后向后面移动m-1个索引,就是为了找到待删除元素的前面一个元素,从而删除这个元素即可)(之后的终止条件(slow->next=slow),slow就是每一次待删除元素的前面一个节点)
3. 算法分析: 时间复杂度: O(n),空间复杂度: 没有消耗额外空间
### T9
1. 题目表述:合并两个升序的单链表(结果为升序)
2. 题目表述: 就是把其中一个链表作为基准,定义一个fast指针指向头节点,之后就可以把另外一个链表中的元素插入到这个链表中,插入条件就是fast->data<=slow->data&&fast->next->data>=slow->data,但是需要单独考虑头节点和尾节点(尾节点之后就可以接上所有其他的节点)
3. 算法分析: 时间复杂度:O(n),空间复杂度: 没有消耗额外空间
### T10
1. 题目表述: 判断一个单链表是否对称
2. 算法思路: 首先定义一个数组用以存储 单链表中的元素,之后将单链表逆转,依次比较逆转之后的单链表中的元素和数组中的元素,不相同就不对称
3. 算法分析: 时间复杂度:O(n),空间复杂度: 额外消耗了一个数组的空间

